class:: JCurve
summary:: quintic easing function with linear interpolation between easeOut and easeIn
related:: Classes/IEnvGen
categories:: UGens>Granular

description::

This library comes with a selection of different unit shaper functions.
Unit shapers can be used as transfer functions to map the input of a linear ramp signal between 0 and 1 to a non-linear output signal between 0 and 1.

JCurve outputs a quintic easing function that interpolates between easeOut and easeIn curves. The shape parameter controls the interpolation: at 0 it produces a quintic easeOut curve, at 0.5 it produces a linear ramp, and at 1 it produces a quintic easeIn curve.

JCurve is useful for creating non-linear transfer functions for phase shaping synthesis (see SCurve for its cousin that interpolates between sigmoid and seat curves).

classmethods::

method::ar

argument::phase
linear ramp between 0 and 1

argument::shape
shape value between 0 and 1

returns:: a quintic easing function with linear interpolation between easeOut and easeIn

SECTION::1) Examples - Plots

subsection::1.1) Basic transfer function

code::
(
{
	var phase = Phasor.ar(DC.ar(0), 50 * SampleDur.ir);
	JCurve.ar(phase, \shape.kr(0.125));
}.plot(0.02);
)
::

subsection::1.2) Comparing different shape values

code::
(
{
	var phase = Phasor.ar(DC.ar(0), 50 * SampleDur.ir);
	var easeOut = JCurve.ar(phase, 0);
	var linear = JCurve.ar(phase, 0.5);
	var easeIn = JCurve.ar(phase, 1);
	[easeOut, linear, easeIn];
}.plot(0.02).superpose_(true).plotColor_([Color.red, Color.blue, Color.green]);
)
::

subsection::1.3) Phase distortion synthesis application - Phase Shaping

code::
(
{
	var phase = Phasor.ar(DC.ar(0), 50 * SampleDur.ir);
	var warpedPhase = JCurve.ar(phase, \shape.kr(0.125));
	cos(warpedPhase * 2pi).neg;
}.plot(0.02);
)
::

SECTION::2) Examples - Audio

subsection::2.1) Phase shaping synthesis application

code::
(
{
	var phase = Phasor.ar(DC.ar(0), 110 * SampleDur.ir);
	var warpedPhase = JCurve.ar(phase, MouseX.kr(0, 1));
	var sig = cos(warpedPhase * 2pi).neg;
	sig!2 * 0.1;
}.play;
)
::

subsection::2.2) Pulsar Synthesis with Phase shaping for frequency trajectory per grain

code::
(
var lfo = {

    var measurePhase = Phasor.ar(DC.ar(0), \rate.kr(0.5) * SampleDur.ir);
    var stepPhase = (measurePhase * \stepsPerMeasure.kr(2)).wrap(0, 1);

    var measureLFO = HanningWindow.ar(measurePhase, \skewA.kr(0.75));
    var stepLFO = GaussianWindow.ar(stepPhase, \skewB.kr(0.5), \index.kr(1));

    stepLFO * measureLFO;
};

{
    var numChannels = 8;

    var reset, flux, tFreqMod, tFreq, overlap;
    var events, voices, windowPhases, triggers;
    var grainFreq, grainPhases, grainWindows;
    var grainOscs, grains, sig;

    reset = Trig1.ar(\reset.tr(0), SampleDur.ir);

    flux = LFDNoise3.ar(\fluxMF.kr(1));
    flux = 2 ** (flux * \fluxMD.kr(0.5));

    tFreqMod = lfo.().linlin(0, 1, 1, 50);
    tFreq = \tFreq.kr(20) * flux * tFreqMod;

    grainFreq = \freq.kr(1200) * flux;
    overlap = \overlap.ar(5); // has to be audio rate, we will latch that later!

    events = SchedulerCycle.ar(tFreq, reset);

    voices = VoiceAllocator.ar(
        numChannels: numChannels,
        trig: events[\trigger],
        rate: grainFreq / overlap, // grain duration depending on grainFreq scaled by overlap
        subSampleOffset: events[\subSampleOffset],
    );

    grainWindows = HanningWindow.ar(
        phase: voices[\phases],
        skew: \skew.kr(0.01)
    );

    // phase shaping for a frequency trajectory per grain:
    // 1.) using normalized phases into JCurve
    // 2.) scaling to number of cycles by latched overlap before wrapping between 0 and 1
	grainPhases = JCurve.ar(voices[\phases], MouseX.kr(0, 1));
    grainPhases = (grainPhases * Latch.ar(overlap, voices[\triggers])).wrap(0, 1);

    grainOscs = SinOsc.ar(DC.ar(0), grainPhases * 2pi);

    grains = grainOscs * grainWindows;

    grains = PanAz.ar(2, grains, \pan.kr(0));
    sig = grains.sum;

    sig = LeakDC.ar(sig);
    sig * 0.1;
}.play;
)
::

