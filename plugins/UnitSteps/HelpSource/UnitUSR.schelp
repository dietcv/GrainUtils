class:: UnitUSR
summary:: Universal Shift Register with stepped or interpolated, reverse encoded 3-bit and 8-bit outputs
related:: Classes/IEnvGen
categories:: UGens>Granular

description::

This library comes with a selection of different unit shaper functions.
Unit shapers can be used as transfer functions to map the input of a linear ramp signal between 0 and 1 to a non-linear output signal between 0 and 1.

UnitUSR stores and rotates bits based on linear ramp signals between 0 and 1.
Each ramp cycle advances the register, rotating existing data and potentially adding new data to create evolving patterns.

The shift register rotates for every ramp cycle either to the left or the right, where the rotation amount is set with the rotate parameter between -16 and 16.
The current loop point of the shift register can be set with the length parameter between 1 and 16. 
Bit rotation is similar to shifting but without losing any data. Any bits shifted off the left end appear at the right and vice versa.

The shift register extracts the current least significant bit (LSB) for every ramp cycle, 
where the chance parameter between 0 and 1 sets the probability for the extracted bit to get inverted via XOR logic 
with a random value before added back to the register.

The reset parameter clears the state of the shift register.

UnitUSR has two reverse encoded outputs, 3-bit and 8-bit.
The reverse encoding provides contrapuntal motion between the two outputs, which is useful when driving complementary voices.

classmethods::

method::ar

argument::phase
linear ramp between 0 and 1

argument::chance
chance parameter between 0 and 1 - probability for LSB inversion via XOR logic

argument::length
length parameter between 1 and 16 - sets the active register size and loop point

argument::rotate
rotation amount between -16 and 16 - rotates register left (positive) or right (negative) on each ramp cycle

argument::interp
0 = no interpolation (stepped values)
1 = cosine interpolation (smooth transitions between values)

argument::reset
reset trigger - clears the shift register state when triggered

returns:: stepped or interpolated, reverse encoded 3-bit and 8-bit outputs from the shift register.
The outputs can be accessed via key from a dictionary (e.g. register[\bit3], register[\bit8])

SECTION::1) Examples - Plots

subsection::1.1) The reverse encoded 3-bit and 8-bit outputs with no interpolation (stepped)

code::
(
{
	var phase, register;

	RandSeed.kr(\seedtrg.kr(1), \seed.kr(500));

	phase = Phasor.ar(DC.ar(0), 1000 * SampleDur.ir);
	register = UnitUSR.ar(
		phase: phase,
		chance: 0.5,
		length: 8,
		rotate: 1,
		interp: 0,
		reset: 0
	);

	[
		register[\bit3],
		register[\bit8]
	];

}.plot(0.02);
)
::

subsection::1.2) The reverse encoded 3-bit and 8-bit outputs with cosine interpolation (smooth)

code::
(
{
	var phase, register;

	RandSeed.kr(\seedtrg.kr(1), \seed.kr(500));

	phase = Phasor.ar(DC.ar(0), 1000 * SampleDur.ir);
	register = UnitUSR.ar(
		phase: phase,
		chance: 0.5,
		length: 8,
		rotate: 1,
		interp: 1,
		reset: 0
	);

	[
		register[\bit3],
		register[\bit8]
	];

}.plot(0.02);
)
::

SECTION::2) Examples - Audio

subsection::2.1) Overlapping Grains with Voice Allocation and Complementary Voices

code::
(
{
    var numChannels = 8;
    var numSpeakers = 2;

    var reset, tFreq;
    var events, register, voices, calcGrainData;
    var grains, sig, pan;

    reset = Trig1.ar(\reset.tr(0), SampleDur.ir);
    tFreq = \tFreq.kr(10);

    events = SchedulerCycle.ar(tFreq, reset);

	register = UnitUSR.ar(
		phase: events[\phase],
        chance: 0.5,
        length: 8,
        rotate: 1,
		interp: 0,
		reset: reset
	);

	voices = VoiceAllocator.ar(
		numChannels: numChannels,
		trig: events[\trigger],
		rate: events[\rate] / \overlap.kr(4),
		subSampleOffset: events[\subSampleOffset],
	);

	calcGrainData = { |chainID|

		var grainWindows;
		var grainFreq, grainFreqs;
		var grainPhases, grainOscs;

		grainWindows = ExponentialWindow.ar(
			phase: voices[\phases],
			skew: \skew.kr(0.05),
			shape: \shape.kr(0)
		);

		grainFreq = case
		{ chainID == \A } {
			var mod = register[\bit3] * 2 - 1;
			\freqA.kr(110) * (2 ** (mod * \freqMDA.kr(1)));
		}
		{ chainID == \B } {
			var mod = register[\bit8] * 2 - 1;
			\freqB.kr(660) * (2 ** (mod * \freqMDB.kr(2)));
		};
		grainFreqs = Latch.ar(grainFreq, voices[\triggers]);

		grainPhases = RampIntegrator.ar(
			trig: voices[\triggers],
			rate: grainFreqs,
			subSampleOffset: events[\subSampleOffset]
		);
		grainOscs = SinOsc.ar(DC.ar(0), grainPhases * 2pi);

		grainOscs * grainWindows;
	};

	grains = XFade2.ar(
		inA: calcGrainData.(\A),
		inB: calcGrainData.(\B),
		pan: \mix.kr(0.5) * 2 - 1
	);

    pan = UnitWalk.ar(voices[\phases]);
    grains = PanAz.ar(
        numChans: numSpeakers,
        in: grains,
        pos: pan.linlin(0, 1, -1 / numSpeakers, (2 * numSpeakers - 3) / numSpeakers);
    );
    sig = grains.sum;

    sig = LeakDC.ar(sig);
    sig * 0.1;
}.play;
)
::

subsection::2.2) Indexing into MultiChannel Dswitch1

code::
(
var multiChannelDswitch = { |triggers, reset, index, arrayOfItems, numOfItems, repeatItem|
	var indexQuantized = (index * numOfItems).floor;
	var demand = Ddup(repeatItem, Dswitch1(arrayOfItems, indexQuantized));
	triggers.collect{ |localTrig|
		Demand.ar(localTrig + reset, reset, demand)
	};
};

var tuning = Tuning.new((0..12) * (3.ratiomidi / 13), 3.0, "Bohlen-Pierce").ratios;
var degrees = [0, 5, 6, 7, 4, 0];
var arrayOfRatios = degrees.collect{ |degree| tuning[degree] };

{
    var numChannels = 8;
    var numSpeakers = 2;

    var reset, tFreq;
    var events, register, voices, calcGrainData;
    var grains, sig, pan;

	RandSeed.kr(\seedtrg.kr(1), \seed.kr(300));

    reset = Trig1.ar(\reset.tr(0), SampleDur.ir);
    tFreq = \tFreq.kr(10);

    events = SchedulerCycle.ar(tFreq, reset);

    register = UnitUSR.ar(
        phase: events[\phase],
        chance: 1,
        length: 8,
        rotate: 1,
        interp: 0,
        reset: reset
    );

    voices = VoiceAllocator.ar(
        numChannels: numChannels,
        trig: events[\trigger],
        rate: events[\rate] / \overlap.kr(4),
        subSampleOffset: events[\subSampleOffset],
    );

    calcGrainData = { |chainID|

        var grainFreqs, grainPhases;
		var grainOscs, grainWindows;

        grainWindows = ExponentialWindow.ar(
            phase: voices[\phases],
            skew: \skew.kr(0.03),
            shape: \shape.kr(0)
        );

        grainFreqs = case
        { chainID == \A } {
			var mod = multiChannelDswitch.(
				voices[\triggers],
				reset,
				register[\bit3],
				arrayOfRatios,
				\numOfItemsA.kr(6),
				\repeatItemA.kr(1)
			);
            \freqA.kr(220) * mod;
        }
        { chainID == \B } {
			var mod = multiChannelDswitch.(
				voices[\triggers],
				reset,
				register[\bit8],
				arrayOfRatios,
				\numOfItemsB.kr(6),
				\repeatItemB.kr(1)
			);
            \freqB.kr(440) * mod;
        };

        grainPhases = RampIntegrator.ar(
            trig: voices[\triggers],
            rate: grainFreqs,
            subSampleOffset: events[\subSampleOffset]
        );
        grainOscs = SinOsc.ar(DC.ar(0), grainPhases * 2pi);

        grainOscs * grainWindows;
    };

    grains = XFade2.ar(
        inA: calcGrainData.(\A),
        inB: calcGrainData.(\B),
        pan: \mix.kr(0.5) * 2 - 1
    );

    pan = UnitWalk.ar(voices[\phases]);
    grains = PanAz.ar(
        numChans: numSpeakers,
        in: grains,
        pos: pan.linlin(0, 1, -1 / numSpeakers, (2 * numSpeakers - 3) / numSpeakers);
    );
    sig = grains.sum;

    sig = LeakDC.ar(sig);
    sig * 0.1;
}.play;
)
::