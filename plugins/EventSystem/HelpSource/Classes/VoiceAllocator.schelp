class:: VoiceAllocator
summary:: Allocation of sub-sample accurate events on the server
related:: Classes/PulseDivider
categories:: UGens>Granular

description::
You can use VoiceAllocator to allocate sub-sample accurate events across a number of channels for server side polyphony.
VoiceAllocator needs numChannels, a trigger, a rate and a subSampleOffset and outputs multichannel phases and multichannel triggers.
You can access the different outputs via their key from a dictionary.
Together with SchedulerCycle or SchedulerBurst you can use VoiceAllocator for sub-sample accurate granulation.

classmethods::

method::ar

argument::numChannels
number of channels used for polyphony (fixed with SynthDef evaluation)

argument::trig
trigger for example derived from SchedulerCycle or SchedulerBurst

argument::rate
rate in hz for example derived from SchedulerCycle or SchedulerBurst

argument::subSampleOffset
subSampleOffset for example derived from SchedulerCycle or SchedulerBurst

returns:: phases and triggers.
The outputs can be accessed via key from a dictionary (e.g. voices[\phases], voices[\triggers])

SECTION::1) Examples - Plots

subsection::1.1) Overlapping Ramps with Voice Allocation

code::
(
{
    var numChannels = 5;

    var reset, tFreq;
    var events, voices;

    reset = Trig1.ar(\reset.tr(0), SampleDur.ir);

	tFreq = \tFreq.kr(400);

    events = SchedulerCycle.ar(tFreq, reset);

    voices = VoiceAllocator.ar(
        numChannels: numChannels,
        trig: events[\trigger],
        rate: events[\rate] / \overlap.kr(4),
        subSampleOffset: events[\subSampleOffset],
    );

	voices[\phases];

}.plot(0.041);
)
::

subsection::1.2) Modulated and Overlapping Ramps with Voice Allocation

code::
(
{
    var numChannels = 5;

    var reset, tFreqMD, tFreq;
    var events, voices;

    reset = Trig1.ar(\reset.tr(0), SampleDur.ir);

    tFreqMD = \tFreqMD.kr(2);
    tFreq = \tFreq.kr(400) * (2 ** (SinOsc.ar(50) * tFreqMD));

    events = SchedulerCycle.ar(tFreq, reset);

    voices = VoiceAllocator.ar(
        numChannels: numChannels,
        trig: events[\trigger],
        rate: events[\rate] / \overlap.kr(2),
        subSampleOffset: events[\subSampleOffset],
    );

	voices[\phases];

}.plot(0.041);
)
::

subsection::1.3) Modulated Ramps and Overlapping Grains with Voice Allocation

code::
(
var multiChannelDwhite = { |triggers|
    var demand = Dwhite(-1.0, 1.0);
    triggers.collect{ |localTrig|
        Demand.ar(localTrig, DC.ar(0), demand)
    };
};

{
    var numChannels = 5;

    var reset, tFreqMD, tFreq;
    var overlapMD, overlap;
    var events, voices;
    var grainFreqMod, grainFreqs, grainPhases, grainWindows;
    var grainOscs, grains;

    reset = Trig1.ar(\reset.tr(0), SampleDur.ir);

    tFreqMD = \tFreqMD.kr(2);
    tFreq = \tFreq.kr(400) * (2 ** (SinOsc.ar(50) * tFreqMD));

    overlapMD = \overlapMD.kr(0);
    overlap = \overlap.kr(5) * (2 ** (SinOsc.ar(50) * overlapMD));

    events = SchedulerCycle.ar(tFreq, reset);

    voices = VoiceAllocator.ar(
        numChannels: numChannels,
        trig: events[\trigger],
        rate: events[\rate] / overlap,
        subSampleOffset: events[\subSampleOffset],
    );

    grainWindows = HanningWindow.ar(voices[\phases], \skew.kr(0.5));

    grainFreqMod = multiChannelDwhite.(voices[\triggers]);
    grainFreqs = \freq.kr(800) * (2 ** (grainFreqMod * \freqMD.kr(2)));

    grainPhases = RampIntegrator.ar(
        trig: voices[\triggers],
        rate: grainFreqs,
        subSampleOffset: events[\subSampleOffset]
    );

    grainOscs = SinOsc.ar(DC.ar(0), grainPhases * 2pi);
    grains = grainOscs * grainWindows;

}.plot(0.041);
)
::

SECTION::2) Examples - Audio

subsection::2.1) Overlapping Grains with Voice Allocation

code::
(
var multiChannelDwhite = { |triggers|
    var demand = Dwhite(-1.0, 1.0);
    triggers.collect{ |localTrig|
        Demand.ar(localTrig, DC.ar(0), demand)
    };
};

{
    var numChannels = 8;
    var numSpeakers = 2;

    var reset, tFreq;
    var events, voices, windowPhases;
    var grainFreqMod, grainFreqs, grainPhases, grainWindows;
    var grainOscs, grains, sig, pan;

    reset = Trig1.ar(\reset.tr(0), SampleDur.ir);
    tFreq = \tFreq.kr(30);

    events = SchedulerCycle.ar(tFreq, reset);

    voices = VoiceAllocator.ar(
        numChannels: numChannels,
        trig: events[\trigger],
        rate: events[\rate] / \overlap.kr(5),
        subSampleOffset: events[\subSampleOffset],
    );

    grainWindows = HanningWindow.ar(
        phase: voices[\phases],
        skew: \skew.kr(0.03)
    );

    grainFreqMod = multiChannelDwhite.(voices[\triggers]);
    grainFreqs = \freq.kr(800) * (2 ** (grainFreqMod * \freqMD.kr(2)));

    grainPhases = RampIntegrator.ar(
        trig: voices[\triggers],
        rate: grainFreqs,
        subSampleOffset: events[\subSampleOffset]
    );
    grainOscs = SinOsc.ar(DC.ar(0), grainPhases * 2pi);

    grains = grainOscs * grainWindows;

    pan = multiChannelDwhite.(voices[\triggers]);
    grains = PanAz.ar(
        numChans: numSpeakers,
        in: grains,
        pos: pan.linlin(-1, 1, -1 / numSpeakers, (2 * numSpeakers - 3) / numSpeakers);
    );
    sig = grains.sum;

    sig = LeakDC.ar(sig);
    sig * 0.1;
}.play;
)
::


